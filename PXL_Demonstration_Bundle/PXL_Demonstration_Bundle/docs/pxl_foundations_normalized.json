{
  "doc_id": "pxl_formal_language",
  "source": "docs/source/PXL_Formal_Language_Definition.txt",
  "last_normalized": "2026-02-02",
  "total_sections": 24,
  "sections": [
    {
      "section_id": "def_ident",
      "title": "Ident Operator Definition",
      "claim_type": "definition",
      "maps_to": ["pxl_definitions"],
      "formal_anchor": "Ident",
      "authority": "formal",
      "status": "covered",
      "txt_claim": "‚ßü : Identity (self-coherence) [Ident]",
      "coq_definition": "Definition Ident (x y : Obj) : Prop := x = y.",
      "match_quality": "exact",
      "notes": "Symbol ‚ßü maps to Coq definition Ident. Defined as Leibniz equality."
    },
    {
      "section_id": "def_nonequiv",
      "title": "NonEquiv Operator Definition",
      "claim_type": "definition",
      "maps_to": ["pxl_definitions"],
      "formal_anchor": "NonEquiv",
      "authority": "formal",
      "status": "covered",
      "txt_claim": "‚áé : Non-equivalence [NonEquiv]",
      "coq_definition": "Parameter NonEquiv : Obj -> Obj -> Prop.",
      "match_quality": "exact",
      "notes": "Primitive Parameter, not defined. Irreducible relation."
    },
    {
      "section_id": "def_inter",
      "title": "Inter Operator Definition",
      "claim_type": "definition",
      "maps_to": ["pxl_definitions"],
      "formal_anchor": "Inter",
      "authority": "formal",
      "status": "covered",
      "txt_claim": "‚áå : Interchange (balance) [Inter]",
      "coq_definition": "Definition Inter (x y : Obj) : Prop := exists z, Ident z x /\\ Ident z y.",
      "match_quality": "exact",
      "notes": "Defined via shared witness structure."
    },
    {
      "section_id": "def_pimp",
      "title": "PImp Operator Definition",
      "claim_type": "definition",
      "maps_to": ["pxl_definitions"],
      "formal_anchor": "PImp",
      "authority": "formal",
      "status": "covered",
      "txt_claim": "‚üπ : Implication [PImp]",
      "coq_definition": "Definition PImp (P Q : Prop) : Prop := P -> Q.",
      "match_quality": "exact",
      "notes": "PImp aliased to Coq implication (‚Üí)."
    },
    {
      "section_id": "def_mequiv",
      "title": "MEquiv Operator Definition",
      "claim_type": "definition",
      "maps_to": ["pxl_definitions"],
      "formal_anchor": "MEquiv",
      "authority": "formal",
      "status": "covered",
      "txt_claim": "‚©™ : Modal coherence equivalence [MEquiv]",
      "coq_definition": "Definition MEquiv (P Q : Prop) : Prop := P <-> Q.",
      "match_quality": "exact",
      "notes": "MEquiv aliased to Coq biconditional (‚Üî)."
    },
    {
      "section_id": "notation_constants",
      "title": "Constants Notation",
      "claim_type": "notation",
      "maps_to": [],
      "formal_anchor": null,
      "authority": "explanatory_only",
      "status": "non-formal",
      "txt_claim": "Constants: a, b, c, ..., z",
      "coq_definition": null,
      "match_quality": "n/a",
      "notes": "Notational convention for constant symbols. No formal definition required."
    },
    {
      "section_id": "notation_variables",
      "title": "Variables Notation",
      "claim_type": "notation",
      "maps_to": [],
      "formal_anchor": null,
      "authority": "explanatory_only",
      "status": "non-formal",
      "txt_claim": "Variables: x, y, z",
      "coq_definition": null,
      "match_quality": "n/a",
      "notes": "Notational convention for variable symbols. No formal definition required."
    },
    {
      "section_id": "notation_modal_ops",
      "title": "Modal Operators Notation",
      "claim_type": "notation",
      "maps_to": [],
      "formal_anchor": null,
      "authority": "explanatory_only",
      "status": "non-formal",
      "txt_claim": "Modal Operators: ‚ñ° (necessity), ‚óá (possibility)",
      "coq_definition": null,
      "match_quality": "n/a",
      "notes": "Standard modal logic notation. Semantic grounding in S5_Kripke.v but notation itself is conventional."
    },
    {
      "section_id": "notation_other_ops",
      "title": "Other Operators Notation",
      "claim_type": "notation",
      "maps_to": [],
      "formal_anchor": null,
      "authority": "explanatory_only",
      "status": "non-formal",
      "txt_claim": "‚àº : Negation; ‚âÄ : Conflation (misalignment); ‚´¥ : Dichotomy (excluded middle); ‚üº : Grounded entailment; ‚äó : S2 operator (axiom of choice / modal composition); ‚äï : Addition (arithmetic domain); ‚ä§ : Truth (verum); ‚ä• : Falsity (falsum)",
      "coq_definition": null,
      "match_quality": "n/a",
      "notes": "Notational conventions for operators. Some have formal definitions elsewhere (e.g., S2 in PXL_S2_Axioms.v), but notation listing itself is non-formal."
    },
    {
      "section_id": "pred_entails",
      "title": "Entails Predicate",
      "claim_type": "definition",
      "maps_to": ["pxl_definitions"],
      "formal_anchor": "entails",
      "authority": "formal",
      "status": "covered",
      "txt_claim": "entails : Obj ‚Üí Prop ‚Üí Prop",
      "coq_definition": "Parameter entails : Obj -> Prop -> Prop.",
      "match_quality": "exact",
      "notes": "Primitive predicate parameter."
    },
    {
      "section_id": "pred_grounded_in",
      "title": "Grounded_in Predicate",
      "claim_type": "definition",
      "maps_to": ["pxl_definitions"],
      "formal_anchor": "grounded_in",
      "authority": "formal",
      "status": "covered",
      "txt_claim": "grounded_in : Prop ‚Üí Obj ‚Üí Prop",
      "coq_definition": "Parameter grounded_in : Prop -> Obj -> Prop.",
      "match_quality": "exact",
      "notes": "Primitive predicate parameter."
    },
    {
      "section_id": "pred_incoherent",
      "title": "Incoherent Predicate",
      "claim_type": "definition",
      "maps_to": ["pxl_definitions"],
      "formal_anchor": "incoherent",
      "authority": "formal",
      "status": "covered",
      "txt_claim": "incoherent : Prop ‚Üí Prop",
      "coq_definition": "Parameter incoherent : Prop -> Prop.",
      "match_quality": "exact",
      "notes": "Primitive predicate parameter."
    },
    {
      "section_id": "pred_coherence",
      "title": "Coherence Predicate",
      "claim_type": "definition",
      "maps_to": ["pxl_definitions"],
      "formal_anchor": "coherence",
      "authority": "formal",
      "status": "covered",
      "txt_claim": "coherence : Obj ‚Üí Prop",
      "coq_definition": "Parameter coherence : Obj -> Prop.",
      "match_quality": "exact",
      "notes": "Primitive predicate parameter."
    },
    {
      "section_id": "grammar_wff",
      "title": "Well-Formed Formula Rules",
      "claim_type": "grammatical_rule",
      "maps_to": [],
      "formal_anchor": null,
      "authority": "explanatory_only",
      "status": "non-formal",
      "txt_claim": "Atomic formula: Px, Qxy, R(x); If œÜ is WFF, then ‚ñ°œÜ and ‚óáœÜ are WFF; If œÜ and œà are WFF, then œÜ ‚üπ œà, œÜ ‚áå œà, and œÜ ‚©™ œà are WFF; If œÜ is WFF, then ‚àºœÜ is WFF; If x is variable and œÜ is WFF, then ‚àÄx œÜ and ‚àÉx œÜ are WFF",
      "coq_definition": null,
      "match_quality": "n/a",
      "notes": "Grammatical formation rules for language. Not formal definitions or theorems."
    },
    {
      "section_id": "axiom_modus_groundens",
      "title": "Modus Groundens",
      "claim_type": "axiom",
      "maps_to": ["pxl_kernel_axioms"],
      "formal_anchor": "modus_groundens",
      "authority": "formal",
      "status": "covered",
      "txt_claim": "‚ñ°(x ‚ßü y) ‚üπ entails x P ‚üπ entails y P",
      "coq_definition": "Axiom modus_groundens : forall x y : Obj, forall P : Prop, Box (Ident x y) -> entails x P -> entails y P.",
      "match_quality": "exact",
      "notes": "Irreducible axiom in kernel."
    },
    {
      "section_id": "axiom_triune_dep_sub",
      "title": "Triune Dependency Substitution",
      "claim_type": "axiom",
      "maps_to": ["pxl_kernel_axioms"],
      "formal_anchor": "triune_dependency_substitution",
      "authority": "formal",
      "status": "covered",
      "txt_claim": "grounded_in œÜ ùïÄ‚ÇÅ ‚üπ grounded_in œà ùïÄ‚ÇÇ ‚üπ œÜ ‚©™ œà ‚üπ coherence ùïÜ",
      "coq_definition": "Axiom triune_dependency_substitution : forall phi psi : Prop, grounded_in phi I1 -> grounded_in psi I2 -> MEquiv phi psi -> coherence NB.",
      "match_quality": "exact",
      "notes": "Irreducible axiom in kernel. Symbols ùïÄ‚ÇÅ/ùïÄ‚ÇÇ/ùïÜ map to I1/I2/NB in code."
    },
    {
      "section_id": "axiom_privative_collapse",
      "title": "Privative Collapse",
      "claim_type": "axiom",
      "maps_to": ["pxl_kernel_axioms"],
      "formal_anchor": "privative_collapse",
      "authority": "formal",
      "status": "covered",
      "txt_claim": "‚àº(‚óá(entails ùïÜ P)) ‚üπ incoherent P",
      "coq_definition": "Axiom privative_collapse : forall P : Prop, ~ (Dia (entails NB P)) -> incoherent P.",
      "match_quality": "exact",
      "notes": "Irreducible axiom in kernel."
    },
    {
      "section_id": "axiom_grounding_entails",
      "title": "Grounding Entailment",
      "claim_type": "axiom",
      "maps_to": ["pxl_kernel_axioms"],
      "formal_anchor": "grounding_yields_entails",
      "authority": "formal",
      "status": "covered",
      "txt_claim": "grounded_in P x ‚üπ entails x P",
      "coq_definition": "Axiom grounding_yields_entails : forall x : Obj, forall P : Prop, grounded_in P x -> entails x P.",
      "match_quality": "exact",
      "notes": "Irreducible axiom in kernel."
    },
    {
      "section_id": "axiom_coherence_lift",
      "title": "Coherence Lifting",
      "claim_type": "axiom",
      "maps_to": ["pxl_kernel_axioms"],
      "formal_anchor": "coherence_lifts_entailment",
      "authority": "formal",
      "status": "covered",
      "txt_claim": "coherence ùïÜ ‚üπ entails x P ‚üπ entails ùïÜ P",
      "coq_definition": "Axiom coherence_lifts_entailment : forall x : Obj, forall P : Prop, coherence NB -> entails x P -> entails NB P.",
      "match_quality": "exact",
      "notes": "Irreducible axiom in kernel."
    },
    {
      "section_id": "axiom_global_truth",
      "title": "Global Truth",
      "claim_type": "axiom",
      "maps_to": ["pxl_kernel_axioms"],
      "formal_anchor": "entails_global_implies_truth",
      "authority": "formal",
      "status": "covered",
      "txt_claim": "entails ùïÜ P ‚üπ P",
      "coq_definition": "Axiom entails_global_implies_truth : forall P : Prop, entails NB P -> P.",
      "match_quality": "exact",
      "notes": "Irreducible axiom in kernel."
    },
    {
      "section_id": "inference_modal_priority",
      "title": "Modal Priority",
      "claim_type": "inference_rule",
      "maps_to": [],
      "formal_anchor": null,
      "authority": "explanatory_only",
      "status": "non-formal",
      "txt_claim": "ùïÄ‚ÇÅ evaluation precedes ùïÄ‚ÇÇ, ùïÄ‚ÇÇ precedes ùïÄ‚ÇÉ (strict sequencing)",
      "coq_definition": null,
      "match_quality": "n/a",
      "notes": "Operational evaluation ordering. Not a formal theorem or axiom."
    },
    {
      "section_id": "inference_identity_frag",
      "title": "Identity Fragmentation",
      "claim_type": "inference_rule",
      "maps_to": [],
      "formal_anchor": null,
      "authority": "explanatory_only",
      "status": "non-formal",
      "txt_claim": "‚àº(x ‚ßü x) ‚üπ x = ‚ä• (privation collapse)",
      "coq_definition": null,
      "match_quality": "n/a",
      "notes": "Derived inference pattern. Not stated as axiom or proven theorem in baseline."
    },
    {
      "section_id": "semantic_domain",
      "title": "Semantic Domain",
      "claim_type": "semantic_specification",
      "maps_to": [],
      "formal_anchor": null,
      "authority": "explanatory_only",
      "status": "non-formal",
      "txt_claim": "Domain: D = {ùïÜ, ùïÄ‚ÇÅ, ùïÄ‚ÇÇ, ùïÄ‚ÇÉ, W‚ÇÅ...Wn}",
      "coq_definition": null,
      "match_quality": "n/a",
      "notes": "Domain enumeration. Object constants exist in PXL_Kernel_Axioms.v but domain listing itself is explanatory."
    },
    {
      "section_id": "semantic_access_relation",
      "title": "Accessibility Relation",
      "claim_type": "semantic_specification",
      "maps_to": ["s5_kripke"],
      "formal_anchor": "S5 frame",
      "authority": "formal",
      "status": "covered",
      "txt_claim": "Accessibility Relation: S5 modal frame (reflexive, symmetric, transitive)",
      "coq_definition": "Definition S5_frame : equivalence_relation R.",
      "match_quality": "equivalent",
      "notes": "S5 frame proven in S5_Kripke.v with equivalence relation structure."
    },
    {
      "section_id": "semantic_valuation",
      "title": "Valuation Function",
      "claim_type": "semantic_specification",
      "maps_to": [],
      "formal_anchor": null,
      "authority": "explanatory_only",
      "status": "non-formal",
      "txt_claim": "Valuation: ‚ü¶œÜ‚üß·µÇ = true iff œÜ holds in all accessible worlds from W",
      "coq_definition": null,
      "match_quality": "n/a",
      "notes": "Semantic valuation definition. General Kripke semantics convention, not system-specific formal claim."
    }
  ]
}
